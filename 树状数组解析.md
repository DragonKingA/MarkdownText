# 树状数组

---

## 应用场景

现有一个长度为 `n` 的数组 `a[]`，要求完成 `q` 次操作，操作类型有：

* `i c`		给 `a[i]` 加上数 `c`
* `x y c`	 给区间 `[x, y]` 上的每个数都加上数 `c`
* `x y`        查询区间 `[x, y] `上所有数的和

暴力解法：直接维护原数组 `a[]`

* 单点修改：`O(1)`
* 区间修改：`O(n)`
* 求区间和：`O(n)`


树状数组解法：

* 单点修改、区间修改、求区间和：O(log~2~n)

总体来说树状数组运作起来是非常快的。

---

## 基本概念

![树状数组](D:\MarkdownText\image\数据结构\树状数组\树状数组.png)

通过观察树状数组图可以探求规律：

```cpp
t[1] = a[1]					    = a[1]
t[2] = a[1] + a[2]				= a[1] + a[2]
t[3] = a[3]					    = a[3]
t[4] = t[2] + t[3] + a[4]		 = a[1] + a[2] + a[3] + a[4]
t[5] = a[5]					    = a[5]
t[6] = t[5] + a[6]				= a[5] + a[6]
t[7] = a[7]					    = a[7]
t[8] = t[4] + t[6] + t[7] + a[8]  = a[1] + a[2] + a[3] + a[4] + a[5] + a[6] + a[7] + a[8]
```

故对于树状数组 `t[i]` ，有如下性质：

* 当 `i` 为奇数时，`t[i]` 只代表一个原值即 `a[i]`；

* 当 `i` 为偶数时，`t[i]` 则代表一段长为 **2^k** `(k ∈ N*)` 的区间和（从 `a[i]` 开始**往前**加到 `a[i - 2^k + 1]`），如 `t[6]` 代表长为 `2` 的区间和、`t[12]` 代表长为 `4` 的区间和；

  仅当 **i = 2^m^** (m ∈ N*) 时，`t[i]` 则是一段**严格的后缀和**，如 `t[8] = Σa[8 ... 1]` 、`t[4] = Σa[4 ... 1]`  等。

那么要得出 `t[i]` 所管辖的区间长度，由于上述信息处处与 2 的次幂相关，通过观察其二进制性质，`t[6] = t[ 0110 ]` 有 `2` 项、`t[4] = t[ 0100 ]` 有 `3` 项、 `t[8] = t[ 1000 ]` 有 8 项，不难发现：

  * **k** 就是 `i` 的二进制数的**后缀0个数**，则 **2^k** 就代表 `i` 的二进制数的末尾1的二进制数

例如：

* 当 i = 6，  二进制数为 011**0**，则 k = 1，项数为 2^k^ = 2 即 0010 = 2；
* 当 i = 12，二进制数为 11**00**，则 k = 2，项数为 2^k^ = 4 即 0100 = 4。

核心性质：每个结点存储信息的方式类似后缀和思想（并非完整的后缀和）

> **`t[i]` 表示 `[i - 2^k + 1, i]` 的区间和**



---

## 巧妙的 lowbit(x)

此时我们定义函数 **lowbit(x)** 来获取 `x` 的二进制数的 **末尾1** 的二进制数

假设 `x = 44` 即 `0010 1100` ，现要依据 `x` 得到 末尾1 `0000 0100`  ：

* 首先要使得 末尾1 的左侧全变成 **0**，即存在运算 **⊗** 使二进制数 **n** 的每位数都变成 **0** 即 **永假**，

  不难想到：逻辑运算里 `p ∧ ┐p` 永假 -------> 二进制运算里 `n & ~n` 结果永假，

  得到 `~x = ~(0010 1100) =  1101 0011` ，而 `x & ~x = 0000 0000` 显然不是所求，故还需要更改运算 **⊗**。

* 现需 **保留末尾1及其后缀0**，由于 **末尾1** 的右侧必为 **0** 即取反后必为 **1**，此时 `~x` 右侧的 **0011** 与 `x` 右侧的 **0100** 只差 **+1**，此时 `~x + 1 = 1101 0100`，故 `x & (~x + 1)`  即所求。

其中，取反然后加1的操作莫名熟悉——即负数的**补码**，所以我们可以直接获得 **x** 的负数的补码 即 **-x**，

最终函数内容被简化成 `x & -x`，即

```c++
#define lowbit(x) ((x) & -(x))
```

此时核心性质可表达为：

> **`t[i]` 表示 `[i - lowbit(i) + 1, i]` 的区间和**



---

## 基本操作

* 区间查询

即求 `[1, x]`区间前缀和 `S(x)`；

根据核心性质，这一段 区间和 一般包含**若干个结点**存储的类后缀和；

如设输入数列 `a[i] = i`，求区间和`[1, 14]`即 `x = 14` 时，显然该区间上包括 三个主结点 `14 12 8`，

即 `S(14) = t[14] + t[12] + t[8] = (13 + 14) + (9 + 10 + 11 + 12) + (1 + 2 + 3 + 4 + 5 + 6 + 7 + 8) = 27 + 42 + 36 = 105`

![树状数组2](D:\MarkdownText\image\数据结构\树状数组\树状数组2.png)

如何实现遍历 `14 -> 12 -> 8` 来求区间和 `Σa[1 ... 14]` ？

由核心性质可以推出 `t[x]` 的前一个结点是 `t[x - lowbit(x)]`，以此类推可以遍历到所有前面的结点，直到囊括区间 `a[1 ... x]`

则 `14 -> 12 -> 8` 即每次 `x -= lowbit(x)` 进行结点跳跃。

查询 `[1, x]` 区间和代码实现如下：

```c++
int sum(int x)
{
    int res = 0;
    for(; x > 0; x -= lowbit(x);)
		res += tree[x];
    return res;
}
```

根据前缀和性质，可求得`[x, y]` 的区间和：

```c++
S(x, y) = sum(y) - sum(x - 1)
```



* 单点修改

如图，下级结点的修改会影响**所有**上级结点的类**后缀和**值，即需要处理至树状数组的顶端 `n`。

它是相对于查询区间和的逆操作，假设现在要给 `t[9]` 加上值 `d` ，不难发现，`9 -> 10 -> 12 -> 16`是末尾1不断**向高位推进**的过程，即操作 `x += lowbit(x)`

![树状数组3](D:\MarkdownText\image\数据结构\树状数组\树状数组3.png)

单点修改代码实现如下：

```c++
void update(int x, int d)//更新结点后缀和，d 即变化值
{
    for(; x <= n; x += lowbit(x))//n 为树状数组大小（数列长度）
    {
        tree[x] += d;
    }
}
```

以上就是基本树状数组（维护原数组前缀和，仅可单点修改 + 区间查询）。

### 单点修改 + 区间查询

实现模板：

[洛谷 P3374 树状数组 1](https://www.luogu.com.cn/problem/P3374) 

```c++
#include <cstdio>
#include <iostream>
#include <algorithm>
using namespace std;
#define ll long long
#define lowbit(x) ((x) & -(x))
const int N = 5e5 + 10;
int n, m;
int tree[N];
void update(int x, int d)
{
    for(; x <= n; x += lowbit(x))
        tree[x] += d;
}
int sum(int x)
{
    int res = 0;
    for(; x > 0; x -= lowbit(x))
        res += tree[x];
    return res;
}
int main()
{
    scanf("%d%d", &n, &m);
    for(int i = 1; i <= n; i++)
    {
        int x;
        scanf("%d", &x);
        update(i, x);
    }
    while(m--)
    {
        int op, x, y;
        scanf("%d%d%d", &op, &x, &y);
        if(op == 1) update(x, y);
        else printf("%d\n", sum(y) - sum(x - 1));
    }
    return 0;
}
```



### 区间修改 + 单点查询

由于树状数组缺乏优良的递归搜索性质，它并不能像线段树那样直接修改区间，只能采用 **差分\前缀和思想** 将单点修改操作能作用到区间上，故现在只需要换成维护原数组 `a[i]` 的**差分数组**，操作代码不变。

```c++
//初始化时插入差分
update(i, a[i] - a[i - 1]);
//查询单值 a[x] 即查询前缀和 ∑b[1 ... x]
sum(x);
```

但显然，它的弊端是最终只能查询单点值 `a[x]`。

实现模板：

[洛谷 P3368 树状数组 2](https://www.luogu.com.cn/problem/P3368)

```c++
#include <cstdio>
#include <iostream>
#include <algorithm>
using namespace std;
#define ll long long
#define lowbit(x) ((x) & -(x))
const int N = 5e5 + 10;
int a[N], tree[N];
int n, m;
void update(int x, int d)
{
    for(; x <= n; x += lowbit(x))
        tree[x] += d;
}
int sum(int x)//查询前缀和 ∑b[1 ... x]
{
    int res = 0;
    for(; x > 0; x -= lowbit(x))
        res += tree[x];
    return res;
}
int main()
{
    scanf("%d%d", &n, &m);
    for(int i = 1; i <= n; ++i) 
    {
        scanf("%d", &a[i]);
        update(i, a[i] - a[i - 1]);//插入差分 b[i]
    }
    while(m--)
    {
        int op, x, y;
        ll k;
        scanf("%d", &op);
        if(op == 1)
        {
            scanf("%d%d%d", &x, &y, &k);
            update(x, k);
            update(y + 1, -k);
        }
        else//此时前缀和 ∑b[1 ... x] 即原单值 a[x]
        {
            scanf("%d", &x);
            printf("%d\n", sum(x));
        }
    }
    return 0;
}
```



### 区间修改 + 区间查询

维护差分数组的树状数组如何进行区间查询？现对公式推导简化，寻找便于维护的信息来实现计算区间和：

$$
\begin{aligned}

原数组为& \ a[i] \\  构造差分数组为&\ b[i] = a[i] - a[i - 1]
\\则有&\ a[i] = \sum_{j = 1}^{i}{b[j]}
\\ 故区间[1, n]前缀和为&\ \sum_{i = 1}^{n}{a[i]} = \sum_{i = 1}^{n}{\sum_{j = 1}^{i}{b[j]}}
\\ 展开为
\\ &\ \ \ \ \ a[1] + a[2] + a[3] + ··· + a[n]\\
\\ &= b[1] + (b[1] + b[2]) + (b[1] + b[2] + b[3]) + ··· + (b[1] + b[2] + ··· + b[n])\\
\\ &= n * b[1] + (n - 1) * b[2] + (n - 2) * b[3] + ··· + 1 * b[n]\\
\\ &= \sum_{k = 1}^{n}{(n - k + 1) * b[k]}
\\ &= (n + 1) * \sum_{k = 1}^{n}{b[k]} - \sum_{k = 1}^{n}{k * b[k]}

\end{aligned}
$$

故区间 `[1, x]` 前缀和即 `∑a[1 ... x] = (x + 1) * ∑b[k] - ∑(k * b[k])` ，

其中乘项 `(x + 1)`可视为**常项**（可以等求和的时候再乘上），那么需维护的信息是两个前缀和：`∑b[k]` 和 `∑(k * b[k])`，

故可维护两个基于差分数组 `b[k]` 的树状数组 `t1[N]` 和 `t2[N]`，并**同时更新**它们。

当要给区间 `a[l ... r]` 每个数加上值 `d` 时：

* 对 `t1[i]`，即直接更新 `b[l] += d` 和 `b[r + 1] += -d` ，

  即 `t1[i] += d`。

* 对 `t2[i]`，其真正的变量只有 `b[x]`，此时有 `b[l] += d` 和 `b[r + 1] += -d`，

  亦有 `l * (b[l] + d) = l * b[l] + l * d` 和 `(r + 1) * (b[r + 1] - d) = (r + 1) * b[r + 1] - (r + 1) * d` ，

  故变化量分别为 `l * d` 和 `(r + 1) * (-d)`，

  即 `t2[i] += x * d`。

```c++
//更新 update(x, d) 其中 d 为变化值。
void update(int x, int d)//传递 b[x] 和 x * b[x] 的变化量
{
    for(int i = x; i <= n; i += lowbit(i))
    {
        t1[i] += d;
        t2[i] += x * d;
    }
}
update(x, k);
update(y + 1, -k);

//或者更一般化
void update(int *t, int x, int d)
{
    while(x <= n)
    {
        t[x] += d;
        x += lowbit(x);
    }
}
update(t1, x, d);
update(t1, y + 1, -d);
update(t2, x, x * d);
update(t2, y + 1, -(y + 1) * d);
```

实现模板：

[洛谷 P3372 线段树 1](https://www.luogu.com.cn/problem/P3372)

```c++
//注意开 long long 防数据溢出
#include <cstdio>
#include <algorithm>
#include <iostream>
using namespace std;
#define ll long long
#define lowbit(x) ((x) & -(x))
const int N = 1e5 + 10;
ll t1[N], t2[N];
int n, m;

void update(ll x, ll d)
{
    for(int i = x; i <= n; i += lowbit(i))
    {
        t1[i] += d;    
        t2[i] += x * d;
    }
}
ll sum(ll x)//查询前缀和 ∑a[1 .. x]
{
    ll res = 0;
    for(int i = x; i > 0; i -= lowbit(i))
    {
        res += (x + 1) * t1[i] - t2[i];//记得给 t1[i] 补上乘项 (x + 1)
    }
    return res;
}

int main()
{
    scanf("%d%d", &n, &m);
    ll now, last = 0;
    for(int i = 1; i <= n; ++i)
    {
        scanf("%lld", &now);
        update(i, now - last);//插入差分b[i]
        last = now;
    }
    while(m--)
    {
        ll op, x, y, k;
        scanf("%lld%lld%lld", &op, &x, &y);
        if(op == 1) 
        {
            scanf("%lld", &k);
            update(x, k);
            update(y + 1, -k);
        }
        else
        {
            printf("%lld\n", sum(y) - sum(x - 1));
        }
    }
    return 0;
}
```

---

## 偏序问题 与 权值树状数组

**偏序问题**

定义：

​	设 R 是集合 A 上的一个**二元**关系，若 R 满足：

* **自反性**：对任意 x ∈ A，有 xRx；
* **反对称性**（即 R 对称上不成立）：对任意 x，y ∈ A，若已有 xRy，且 yRx，则必 x = y，即只有自反时满足，否则一旦存在 xRy 就不可能存在对称的 yRx 成立；
* **传递性**：对任意 x，y，z ∈ A，若有 xRy 且 yRz ，则必 xRz 成立。

​	则称 R 为 A 上的偏序关系。

那么**偏序问题**在题目中一般是“求解给定序列中**满足给定偏序关系的关系组组数**”。

拿逆序关系（属于偏序关系的一种）举例：

* 逆序对：指在序列 A 中满足 `ai > aj` 且 `i < j` 的二元对 `<i, j>`。

* 有一序列 `A = {5 4 2 6 3 1}`，诸如 <1, 2>、<3, 6>、<5, 6> 等都是逆序对，逆序对的偏序性主要表现在反对称性（如 <1, 2> 成立，而 <2, 1> 不成立）和传递性（如 <1, 3> 和 <3, 6> 同时成立，那么 <1, 6> 也必成立）。

**二维偏序问题**

此时 R 是**一对互相限制的、共同成立的二元关系**，即此时所寻求的关系组需满足给定**一对偏序关系**，当且仅当两种关系联立成立时才计数。

以此类推，有 **n 维偏序关系**。

**权值树状数组**

除了像普通树状数组维护的就是原序列的数值，还有在原序列的**权值数组**上构建的树状数组 - 权值树状数组。

设序列 `A = {1 4 3 2 3 2}` ，其权值数组为 `B = {1 2 2 1}`。对 `A[i] = x`，其权值数组 `B[x] = x的出现次数`，则 `B` 的大小和 `A`的值域有关。若 `A` 的值域过大，一般像逆序对这类**偏序问题**，需要处理的是数之间的**相对大小关系**，都会进行**离散化处理**后再建立权值数组，并通过维护权值树状数组来担任偏序问题中**统计数的个数**的角色。

具体题中使用细节见[逆序对](https://www.luogu.com.cn/problem/P1908)等题。


---

## 总结

* 结构：完全二叉树（除了最后一层可能会缺结点，并且最后一层剩余的结点都靠左且连续，其余层数一定组成一个满二叉树）

  ![完全二叉树](D:\MarkdownText\image\数据结构\树状数组\完全二叉树.png)

  这就区别于线段树的满二叉树（完美二叉树）结构。

* 注意：树状数组无根（或者说可向上无限延伸），且树状数组首个叶子结点编号必须从 `1` 开始。

* 特点：普通树状数组仅支持  **单点\区间修改** 和 **单点\区间查询** ，码量少，时空复杂度低。

* 缺点：拓展性比线段树差，线段树可以解决树状数组能解决的问题（除非卡空间），但反过来就不一定。

* 应用：树状数组维护的是**前缀和**，“**动态更新并求解前缀和**”是树状数组在做的事。通常考虑能否将题目问题转化为前缀和问题，用树状数组快速解决。多应用于 **偏序问题** 和 维护公式里的求和式。其中偏序问题一般用的是**权值树状数组**（以原序列的值 x 作为下标，表达数 x 在区间内的出现次数），也常常搭配**离散化处理**技巧。

---

## 题目

| 序号 | 题号       | 标题                                                         | 题型                                                         | 难度评级 |
| ---- | ---------- | :----------------------------------------------------------- | ------------------------------------------------------------ | -------- |
| 1    | hdu 1166   | [敌兵布阵](https://vjudge.csgrandeur.cn/problem/HDU-1166)    | 单点修改 + 区间查询                                          | ⭐        |
| 2    | poj 1195   | [Mobile phones](http://poj.org/problem?id=1195)              | 二维基础树状数组                                             | ⭐        |
| 3    | 洛谷 P3368 | [【模板】树状数组 2](https://www.luogu.com.cn/problem/P3368) | 区间修改 + 单点查询                                          | ⭐        |
| 4    | 洛谷 P2357 | [守墓人](https://www.luogu.com.cn/problem/P2357)             | 区间修改 + 区间查询                                          | ⭐⭐       |
| 5    | 洛谷 P1908 | [逆序对](https://www.luogu.com.cn/problem/P1908)             | 偏序问题（权值树状数组） + 离散化                            | ⭐⭐       |
| 6    | 洛谷 P3531 | [[POI2012\]LIT-Letters](https://www.luogu.com.cn/problem/P3531) | 偏序问题（权值树状数组）                                     | ⭐⭐⭐      |
| 7    | 洛谷 P1637 | [三元上升子序列](https://www.luogu.com.cn/problem/P1637)     | 二维偏序问题（权值树状数组）                                 | ⭐⭐⭐      |
| 8    | 洛谷 P2184 | [贪婪大陆](https://www.luogu.com.cn/problem/P2184)           | 区间覆盖问题                                                 | ⭐⭐⭐      |
| 9    | 洛谷 P1972 | [[SDOI2009] HH的项链](https://www.luogu.com.cn/problem/P1972) | 二维偏序问题 + 离线排序                                      | ⭐⭐⭐⭐     |
| 10   | 洛谷 P5094 | [[USACO04OPEN\] MooFest G 加强版](https://www.luogu.com.cn/problem/P5094) | 前缀和 + 排序                                                | ⭐⭐⭐⭐     |
| 11   | 洛谷 P5142 | [区间方差](https://www.luogu.com.cn/problem/P5142)           | 前缀和 + 数论（[逆元\|分数取模](https://blog.csdn.net/godleaf/article/details/79844074)） | ⭐⭐⭐⭐     |
| 12   | 洛谷 P4113 | [[HEOI2012\]采花](https://www.luogu.com.cn/problem/P4113)    | 三维偏序问题 + 离线排序                                      | ⭐⭐⭐⭐⭐    |

