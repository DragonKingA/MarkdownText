#! https://zhuanlan.zhihu.com/p/615592235

# 集训队第三周周报

---

#### **情况总结：**



##### 概要：

​		本周进行了一场atc赛（AC 3题）、队内训练组队赛，将 kuanbin 专题7 - 线段树专题（17 题） 刷干净，重点是了解到不同形式的线段树考点。



##### 训练方向：

​		线段树 刷题



##### 题目完成情况：

​		17 道 线段树题 ：包含基础求和线段树、区间合并、一维染色问题、线段树维护DFS序、混合区间操作（求平方和、立方和等）、二分搜索线段树、基本扫描线问题（矩形面积并、矩形周长并、多次覆盖矩形面积并）、三维扫描线问题（矩体体积并）以及 小技巧：离散化处理等知识点。

---

#### **线段树专题部分题解：** 

#### 染色问题

##### · 一维染色问题

```c++
1.Mayor's posters （一维染色问题 + 特殊离散化处理）
给一个无限长广告牌，给你n个广告和其放置的位置，按照输入数据的顺序放置前后，问能看见几个广告（注意，看见一部分也算）。
题意转换：设每个广告都是独立的一种颜色，放置广告相当于给一个区间染色，问某个区间有多少种颜色。
由于 l, r <= 1e7，需要离散化降低复杂度，并且l和r两两离散，为保证不交叉区间的非连续性，需要离散时 间隔一个数
如输入区间[1, 100],[1, 30],[50, 100]，其答案为3，若连续离散则得到[1, 4],[1, 2],[3, 4]导致答案为2，因此应该将离散数字两两间隔一个数
即[1, 7],[1, 3],[5, 7]，才能得到答案为3，
unique() 的返回值是一个地址指向去重后序列（这个序列不含有重复数值）的 末尾 的 下一个元素
v.erase(unique(v.begin(), v.end()), v.end()) 可以去掉容器中后面重复的元素
    
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
#include <vector>
#include <set>
using namespace std;
#define ll int
#define ls (p << 1)
#define rs (p << 1 | 1)
#define lc ls, pl, mid
#define rc rs, mid + 1, pr
const ll N = 1e6 + 5;
vector<ll> v;
set<ll> st;
pair<ll, ll> que[N];
ll tree[N << 2], n ,T;
void pushdown(ll p)
{
    if(tree[p])
    {
        tree[ls] = tree[rs] = tree[p];
        tree[p] = 0;
    }
}
void update(ll L, ll R, ll p, ll pl, ll pr, ll d)
{
    if(L <= pl && R >= pr)
    {
        tree[p] = d;
        return;
    }
    pushdown(p);
    ll mid = (pl + pr) >> 1;
    if(L <= mid) update(L, R, lc, d);
    if(R > mid) update(L, R, rc, d);
}
void query(ll L, ll R, ll p, ll pl, ll pr)//重点
{
    if(tree[p]) //区间p有颜色就记录
    {
        st.insert(tree[p]);
        return;//区间p有颜色，说明该区间下都为这个颜色，故不用再搜索
    }
    if(pl == pr) return;
    ll mid = (pl + pr) >> 1;
    if(L <= mid) query(L, R, lc);
    if(R > mid) query(L, R, rc);
}
int main()
{
    scanf("%d", &T);
    while(T--)
    {
        v.clear();
        st.clear();
        memset(tree, 0, sizeof(tree));
        scanf("%d", &n);
        for(int i = 1; i <= n; i++)
        {
            ll l, r;
            scanf("%d%d", &l, &r);
            que[i] = make_pair(l, r);
            v.push_back(l);
            v.push_back(r);
        }
        sort(v.begin(), v.end());
        v.erase(unique(v.begin(), v.end()), v.end());
        ll len = v.size();
        for(int i = 1; i < len; i++)
            if(v[i] - v[i - 1] > 1) // 即两区间不连续
                v.push_back(v[i - 1] + 1);
        sort(v.begin(), v.end());
        len = v.size();
        for(int i = 1; i <= n; i++)
        {
            ll L = lower_bound(v.begin(), v.end(), que[i].first) - v.begin() + 1;//记得要使其从1开始，都得加1。
            ll R = lower_bound(v.begin(), v.end(), que[i].second) - v.begin() + 1;
            update(L, R, 1, 1, len, i);
        }
        query(1, len, 1, 1, len);
        printf("%d\n", st.size());
    }
    return 0;
}



2.Count the Colors
题意：在长度为n的线段上，每次操作给其中一个区间染上颜色c，可以覆盖前面的颜色，求最后整条线段上能看到多少种颜色。
l, r <= 8e3，无需离散化
本题重点在于如何联系连续区间(注意区间[1,3][3,5]连续可看作[1,5]，而[1,2][3,4]不连续，因为被[2,3]分开了)。
搞明白涂色的是区间而不是点，染色区间[a,b]并不是把a～b的所有点都染成c，故区间不能取闭区间。
防止不连续区间判断为连续，需要将一侧的端点收束（左端点+1 或 右端点-1）或直接两端点值乘2，来使得连续数字间有中间值，因为连续数字的两个区间其实不连续，
这里可以选择用 左开右闭 区间，设染色区间[l, r]即染色[l + 1, r]上的每个点，对于一个单位区间[0, 1]，将点1染色等同于将[0, 1]染色，
即染色某个点，即染色该点的前一段单位区间。
    
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
#include <set>
#include <map>
using namespace std;
#define ll int
#define ls (p << 1)
#define rs (p << 1 | 1)
const ll N = 8e3 + 5;
ll tree[N << 2], ans[N], last = 0;//重点：记录上次碰到的颜色或者说上次碰到非颜色区间，方便排除连续区间
void pushdown(ll p)
{
    if(tree[p])
    {
        tree[ls] = tree[rs] = tree[p];
        tree[p] = 0;
    }
}
void update(ll L, ll R, ll p, ll pl, ll pr, ll d)
{
    if(tree[p] == d) return;//优化，若已经染成d色，则退出
    if(L <= pl && R >= pr)
    {
        tree[p] = d;
        return;
    }
    pushdown(p);
    ll mid = (pl + pr) >> 1;
    if(L <= mid) update(L, R, ls, pl, mid, d);
    if(R > mid) update(L, R, rs, mid + 1, pr, d);
}
void query(ll p, ll pl, ll pr)//搜索每个线段树区间
{
    if(tree[p])//有颜色
    {
        if(tree[p] != last) 
        {
            ans[tree[p]]++;//非连续区间才计数
            last = tree[p];//更新last
        }
        return;
    }
    if(pl == pr)//到了叶子结点都还没颜色，说明颜色断片，已经不连续了，那就初始化last
    {
        last = 0;
        return;
    }
    ll mid = (pl + pr) >> 1;
    query(ls, pl, mid);
    query(rs, mid + 1, pr);
}
int main()
{
    int n;
    while(~scanf("%d", &n))
    {
        last = 0;
        memset(ans, 0, sizeof(ans));
        memset(tree, 0, sizeof(tree));
        for(int i = 1; i <= n; i++)
        {
            ll l, r, c;
            scanf("%d%d%d", &l, &r, &c);
            update(l + 1, r, 1, 1, N, c + 1);
        }
        query(1, 1, N);
        for(int i = 1; i < N; i++)
            if(ans[i]) printf("%d %d\n", i - 1, ans[i]);
        printf("\n");
    }
    return 0;
}
```



##### · 二维染色问题



```c++


暂无



```



#### 区间合并问题



```c++
1.Tunnel Warfare 
三种操作：单点修改、求最长连续1的个数 和 撤销上一次单点修改
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
#define ls (p << 1)
#define rs (p << 1 | 1)
#define lc ls, pl, mid
#define rc rs, mid + 1, pr
#define ll int
const ll N = 5e4 + 5;

//线段树维护子节点，pre保存区间前缀最长1的个数，suf保存区间后缀最长1的个数
ll tree[N << 2], pre[N << 2], suf[N << 2];

//存在撤回操作，记录村庄被毁的历史
ll history[N];

void push_up(ll p, ll len)//更新区间p的前缀1和后缀1个数
{
    //先传承，再判断左右子区间合并情况
    pre[p] = pre[ls];
    suf[p] = suf[rs];
    //如果左子区间均为1，则可以将值合并到右子区间的前缀1和。右子同理。
    if(pre[ls] == len - (len >> 1)) pre[p] += pre[rs];
    if(suf[rs] == (len >> 1)) suf[p] += suf[ls];
}
void build(ll p, ll pl, ll pr)
{
    if(pl == pr)
    {
        tree[p] = pre[p] = suf[p] = 1;
        return;
    }
    ll mid = (pl + pr) >> 1;
    build(lc);
    build(rc);
    push_up(p, pr - pl + 1);
}
void update(ll x, ll p, ll pl, ll pr, ll d)
{
    if(pl == pr) 
    {
        tree[p] = pre[p] = suf[p] = d;
        return;
    }
    ll mid = (pl + pr) >> 1;
    if(x <= mid) update(x, lc, d);
    else update(x, rc, d);
    push_up(p, pr - pl + 1);
}
ll query(ll x, ll p, ll pl, ll pr)
{
    if(pl == pr) return tree[p];
    ll mid = (pl + pr) >> 1;
    if(x <= mid)//查询点落在左子
    {
        //若查询点落在左子的后缀最长1区间内，直接返回最长连续1；若不是则继续探查左子
        if(x + suf[ls] > mid) return suf[ls] + pre[rs];
        else return query(x, lc);
    }
    else
    {
        if(pre[rs] >= x - mid) return suf[ls] + pre[rs];
        else return query(x, rc);
    }
}
int main()
{
    ll n, q;
    while(~scanf("%d%d", &n, &q))
    {
        ll ind = 0;
        build(1, 1, n);
        while(q--)
        {
            char op[5];
            ll x;
            scanf("%s", &op);
            if(op[0] == 'D')
            {
                scanf("%d", &x);
                update(x, 1, 1, n, 0);
                history[++ind] = x;//依次记录破坏操作
            }
            else if(op[0] == 'Q')
            {
                scanf("%d", &x);
                printf("%d\n", query(x, 1, 1, n));
            }
            else
            {
                x = history[ind--];
                update(x, 1, 1, n, 1);
            }
        }
    }
    return 0;
}



2.Hotel
区间修改 + 统计连续个数
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
#define ls (p << 1)
#define rs (p << 1 | 1)
#define lc ls, pl, mid
#define rc rs, mid + 1, pr
#define ll int
const ll N = 5e4 + 4;
struct nd{
    ll sum, pre, suf;//统计对象为1，即空位置个数
    ll tag;          //为0\1时区间置为0\1
    nd(ll s = 0, ll p = 0, ll sf = 0, ll t = 0) { sum = s, pre = p, suf = sf, tag = t;}
}tree[N << 2];
void addtag(ll p, ll len, ll d)
{
    ll x = d * len;
    tree[p] = nd(x, x, x, d);
}
void push_up(ll p, ll len)
{
    tree[p].pre = tree[ls].pre;
    tree[p].suf = tree[rs].suf;
    
    if(tree[ls].pre == len - (len >> 1)) tree[p].pre += tree[rs].pre;
    if(tree[rs].suf == (len >> 1)) tree[p].suf += tree[ls].suf;
    tree[p].sum = max(max(tree[ls].sum, tree[rs].sum), tree[ls].suf + tree[rs].pre);
}
void push_down(ll p, ll pl, ll pr)
{
    if(tree[p].tag != -1)
    {
        ll mid = pl + pr >> 1;
        addtag(ls, mid - pl + 1, tree[p].tag);
        addtag(rs, pr - mid, tree[p].tag);
        tree[p].tag = -1;
    }
}
void build(ll p, ll pl, ll pr)
{
    ll len = pr - pl + 1;
    tree[p] = nd(len, len, len, -1);
    if(pl == pr) return;
    ll mid = pl + pr >> 1;
    build(lc);
    build(rc);
}
void update(ll L, ll R, ll p, ll pl, ll pr, ll d)
{
    if(L <= pl && R >= pr)
    {
        addtag(p, pr - pl + 1, d);
        return;
    }
    push_down(p, pl, pr);
    ll mid = pl + pr >> 1;
    if(L <= mid) update(L, R, lc, d);
    if(R > mid) update(L, R, rc, d);
    push_up(p, pr - pl + 1);
}
ll query(ll p, ll pl, ll pr, ll k)
{
    if(pl == pr && k == 1) return pl;//特判
    push_down(p, pl, pr);
    //按左端点编号由小到大搜，左->中->右
    ll mid = pl + pr >> 1;
    if(tree[p].sum < k) return 0;
    if(tree[ls].sum >= k)
        return query(lc, k);
    else if(tree[ls].suf + tree[rs].pre >= k)
        return mid - tree[ls].suf + 1;
    else
        return query(rc, k);
}
int main()
{
    ll n, m;
    scanf("%d%d", &n, &m);
    build(1, 1, n);
    while(m--)
    {
        ll op, x, d;
        scanf("%d", &op);
        if(op == 1)
        {
            scanf("%d", &d);
            ll res = query(1, 1, n, d);
            printf("%d\n", res);
            if(res) update(res, res + d - 1, 1, 1, n, 0);
        }
        else
        {
            scanf("%d%d", &x, &d);
            update(x, x + d - 1, 1, 1, n, 1);
        }
    }
    return 0;
}



3.约会安排
需要同时维护两个区间，两区间之间具有单向覆盖关系 + 维护最长连续序列长度。
维护两个时间区间 DS、NS，需要记录连续0个数(最长前缀连续、最长后缀连续 和 最长总连续)
DS T 和 NS T 都要求找一段编号最靠前的长为T的连续空闲空间，而 NS 如果没找到则可以占据 DS 的空间； STUDY!! L R 表示清空[L, R]区间
#include <cstdio>
#include <iostream>
#include <algorithm>
using namespace std;
#define ls (p << 1)
#define rs (p << 1 | 1)
#define lc ls, pl, mid
#define rc rs, mid + 1, pr
#define ll int
const int N = 1e5 + 5;
struct nd{
    ll pre, suf, cnt;//1代表有空间
    ll tag;
    nd(ll a = 0, ll b = 0, ll c = 0, ll d = 0) {pre = a, suf = b, cnt = c, tag = d;}
}tree[2][N << 2];
ll n, m, _;
void addtag(ll p, ll pl, ll pr, ll ind, ll d)
{
    ll len = pr - pl + 1, x = d * len;
    tree[ind][p] = nd(x, x, x, d);
}
void push_up(ll p, ll pl, ll pr, ll i)
{
    ll len = pr - pl + 1;
    tree[i][p].pre = tree[i][ls].pre;
    tree[i][p].suf = tree[i][rs].suf;
    if(tree[i][p].pre == len - (len >> 1)) tree[i][p].pre += tree[i][rs].pre;
    if(tree[i][p].suf == (len >> 1)) tree[i][p].suf += tree[i][ls].suf;
    tree[i][p].cnt = max(max(tree[i][ls].cnt, tree[i][rs].cnt), tree[i][ls].suf + tree[i][rs].pre);
}
void push_down(ll p, ll pl, ll pr, ll i)
{
    ll mid = pl + pr >> 1;
    if(tree[i][p].tag != -1)
    {
        addtag(lc, i, tree[i][p].tag);
        addtag(rc, i, tree[i][p].tag);
        tree[i][p].tag = -1;
    }
}
void build(ll p, ll pl, ll pr)
{
    ll len = pr - pl + 1;
    for(int i = 0; i < 2; i++) tree[i][p] = nd(len, len, len, -1);
    if(pl == pr) return;
    ll mid = pl + pr >> 1;
    build(lc);
    build(rc);
}
void update(ll L, ll R, ll p, ll pl, ll pr, ll ind, ll d)
{
    if(L <= pl && R >= pr)
    {
        addtag(p, pl, pr, ind, d);
        return;
    }
    push_down(p, pl, pr, ind);
    ll mid = pl + pr >> 1;
    if(L <= mid) update(L, R, lc, ind, d);
    if(R > mid) update(L, R, rc, ind, d);
    push_up(p, pl, pr, ind);
}
ll query(ll p, ll pl, ll pr, ll ind, ll d)
{
    if(pl == pr) return pl;
    push_down(p, pl, pr, ind);
    ll mid = pl + pr >> 1;
    if(tree[ind][ls].cnt >= d) return query(lc, ind, d);
    else if(tree[ind][ls].suf + tree[ind][rs].pre >= d) return mid - tree[ind][ls].suf + 1;
    else return query(rc, ind, d);
}
int main()
{
    scanf("%d", &_);
    for(int __ = 1; __ <= _; __++)
    {
        printf("Case %d:\n", __);
        scanf("%d%d", &n, &m);
        build(1, 1, n);
        while(m--)
        {
            char op[5];
            ll T, L, R, pos;
            scanf("%s", &op);
            if(op[0] == 'D')
            {
                scanf("%d", &T);
                if(tree[0][1].cnt < T)//tree[0] 同时受NS、DS区间占用情况的影响，即 DS 只能找tree[0]
                {
                    printf("fly with yourself\n");
                    continue;   
                }
                //DS区间只影响tree[0]
                pos = query(1, 1, n, 0, T);
                update(pos, pos + T - 1, 1, 1, n, 0, 0);
                printf("%d,let's fly\n", pos);
            }
            else if(op[0] == 'N')
            {
                ll res;
                scanf("%d", &T);
                if(tree[1][1].cnt < T)
                {
                    printf("wait for me\n");
                    continue;
                }
                if(tree[0][1].cnt >= T)        //依据题意看DS区间是否有足够的连续空闲区间
                    res = query(1, 1, n, 0, T);
                else                           //再“无视DS区间占用”找
                    res = query(1, 1, n, 1, T);

                update(res, res + T - 1, 1, 1, n, 0, 0);
                update(res, res + T - 1, 1, 1, n, 1, 0);
                printf("%d,don't put my gezi\n", res);
            }
            else
            {
                scanf("%d%d", &L, &R);
                update(L, R, 1, 1, n, 0, 1);
                update(L, R, 1, 1, n, 1, 1);
                printf("I am the hope of chinese chengxuyuan!!\n");
            }
        }
    }
    return 0;
}
```



#### 扫描线

##### 矩形面积并

###### · 一次覆盖问题（基础）

```c++
1.Atlantis
题意：x-y坐标系上有若干个矩形，它们的边分别平行两个坐标轴，求它们的面积并（面积并集），要求重复部分面积只计算一次。
注意：由于x, y是实数，需要离散化处理。由于线段树维护的是x的区间长度，都是区间即不含点，如区间[2, 2]等点不具有意义，所以线段树的叶子结点为区间[pl, pl + 1]。
基本原理：遍历所有扫描线，只要还没遇到其对应的出边时，该入边长度一直有效（指属于当前新矩形的底边长度），每次会得到当前的总有效长度tree[1]，就是新矩形的底边长。
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;
#define ls (p << 1)
#define rs (p << 1 | 1)
#define ll int
#define db double
const int N = 1e3 + 5;
ll n, cnt[N << 2];//cnt[p] 记录当前区间p被覆盖的次数，跟其它节点无关。可判断该区间长度是否有效
//一个节点代表的区间被覆盖的次数不需要继承其父亲的信息，每条入边一一对应一条等长的出边，由该入边产生的覆盖次数cnt应由其对应出边抵消，因此去掉pushdown
db tree[N << 2], X[N << 2];
struct Line{
    db lx, rx, y;
    ll d;//1为入边，-1为出边
    Line(db a = 0, db b = 0, db c = 0, ll dd = 0) {lx = a, rx = b, y = c, d = dd;}
    bool operator <(const Line &x) const{ return y < x.y;}
}line[N << 2];
void push_up(ll p, ll pl, ll pr)
{
    if(cnt[p]) 
        tree[p] = X[pr] - X[pl];
    //区间p长度无效时
    else if(pl + 1 == pr)//叶子结点没办法向下索取有效长度，即后面没有有效长度排队占用，置为0即可
        tree[p] = 0;
    else
        tree[p] = tree[ls] + tree[rs];//向下索取有效长度（或者说到这段有效长度占据区间p了）
}
void update(ll L, ll R, ll p, ll pl, ll pr, ll d)
{
    if(L <= pl && R >= pr)
    {
        cnt[p] += d;
        push_up(p, pl, pr);
        return;
    }
    if(pl + 1 == pr) return;
    ll mid = pl + pr >> 1;
    if(L <= mid) update(L, R, ls, pl, mid, d);
    if(R > mid) update(L, R, rs, mid, pr, d); //注意这里不是 mid + 1

    if(!cnt[p]) tree[p] = tree[ls] + tree[rs];
    //仅区间p没有有效长度时才传值，因为若区间p已经有效，说明它已经是最长的覆盖长度pr-pl。若直接传值则会错误地覆盖这个仍有效的长度。
    //应等区间p被出边抵消时，才把子区间值传上来，即它是有顺序的。
    push_up(p, pl, pr);
}
int main()
{
    int _ = 1;
    while(~scanf("%d", &n))
    {
        if(!n) break;
        memset(tree, 0, sizeof(tree));
        memset(cnt, 0, sizeof(cnt));
        db ans = 0;
        ll ind = 0;
        for(int i = 0; i < n; i++)
        {
            db x1, y1, x2, y2;
            scanf("%lf%lf%lf%lf", &x1, &y1, &x2, &y2);
            line[++ind] = Line(x1, x2, y1, 1);
            X[ind] = x1;
            line[++ind] = Line(x1, x2, y2, -1);
            X[ind] = x2;
        }
        sort(X + 1, X + 1 + ind);
        sort(line + 1, line + 1 + ind);
        ll max_x = unique(X + 1, X + 1 + ind) - X - 1;
        for(int i = 1; i <= ind; i++)
        {
            ans += tree[1] * (line[i].y - line[i - 1].y);//第一条边不计算面积
            ll L = lower_bound(X + 1, X + 1 + max_x, line[i].lx) - X;
            ll R = lower_bound(X + 1, X + 1 + max_x, line[i].rx) - X;
            update(L, R, 1, 1, max_x, line[i].d);
        }
        printf("Test case #%d\nTotal explored area: %.2lf\n\n", _++, ans);
    }
    return 0;
}
```



###### · 多次覆盖问题（进阶）

```c++
1.覆盖的面积
    
写法1：区间处理为[L, R - 1]，线段树叶子结点为一个点即如[1, 1], [3, 3] -- 实际上分别代表区间[1, 2], [3, 4]
#include <cstdio>
#include <algorithm>
#include <iostream>
#include <cstring>
using namespace std;
#define ls (p << 1)
#define rs (p << 1 | 1)
#define ll int
#define db double
const ll N = 1e5 + 5;
ll n, T;
ll cnt[N];
db tree[N], tree2[N], xx[N];//tree[]维护独立有效长度，tree2[]维护被覆盖的有效长度
struct Line{
    db lx, rx, h;
    ll d;
    Line(){}
    Line(db a, db b, db c, ll dd) {lx = a, rx = b, h = c, d = dd;}
    bool operator <(const Line &m) const{ return h < m.h;}
}line[N];
void push_up(ll p, ll pl, ll pr)
{
    if(cnt[p])
        tree[p] = xx[pr + 1] - xx[pl];//注意要线段树区间如[1, 2]代表实际区间[1, 3]，长度按实际区间长度算
    else if(pl == pr)
        tree[p] = 0;
    else
        tree[p] = tree[ls] + tree[rs];

    if(cnt[p] > 1)
        tree2[p] = xx[pr + 1] - xx[pl];
    else if(pl == pr)
        tree2[p] = 0;
    else if(cnt[p] == 1)
        tree2[p] = tree[ls] + tree[rs];
    else
        tree2[p] = tree2[ls] + tree2[rs];
}
void update(ll L, ll R, ll p, ll pl, ll pr, ll d)
{
    if(L <= pl && R >= pr)
    {
        cnt[p] += d;
        push_up(p, pl, pr);
        return;
    }
    if(pl == pr) return;
    ll mid = pl + pr >> 1;
    if(L <= mid) update(L, R, ls, pl, mid, d);
    if(R > mid) update(L, R, rs, mid + 1, pr, d);
    push_up(p, pl, pr);
}
int main()
{
    scanf("%d", &T);
    while(T--)
    {
        memset(cnt, 0, sizeof(cnt));
        memset(tree, 0, sizeof(tree));
        memset(tree2, 0, sizeof(tree2));
        db ans = 0;
        ll ind = 0;
        scanf("%d", &n);
        for(int i = 1; i <= n; i++)
        {
            db x1, y1, x2, y2;
            scanf("%lf%lf%lf%lf", &x1, &y1, &x2, &y2);
            line[++ind] = Line(x1, x2, y1, 1);
            xx[ind] = x1;
            line[++ind] = Line(x1, x2, y2, -1);
            xx[ind] = x2;
        }
        sort(line + 1, line + 1 + ind);
        sort(xx + 1, xx + 1 + ind);
        ll num = unique(xx + 1, xx + 1 + ind) - xx - 1;
        for(int i = 1; i <= ind; i++) 
        {
            ans += tree2[1] * (line[i].h - line[i - 1].h);
            ll L = lower_bound(xx + 1, xx + 1 + num, line[i].lx) - xx;
            ll R = lower_bound(xx + 1, xx + 1 + num, line[i].rx) - xx;
            update(L, R - 1, 1, 1, num, line[i].d);
        }
        printf("%.2lf\n", ans);
    }
    return 0;
}

写法2：将线段树叶子结点设为[pl, pl + 1]，即设定最小结点是一个长度为1的小区间
#include <cstdio>
#include <algorithm>
#include <iostream>
#include <cstring>
using namespace std;
#define ls (p << 1)
#define rs (p << 1 | 1)
#define ll int
#define db double
const ll N = 1e5 + 5;
ll n, T;
ll cnt[N];
db tree[N], tree2[N], xx[N];//tree[]维护有效长度len1(至少覆盖过一次)，tree2[]维护至少被覆盖两次的有效长度len2
struct Line{
    db lx, rx, h;
    ll d;
    Line(){}
    Line(db a, db b, db c, ll dd) {lx = a, rx = b, h = c, d = dd;}
    bool operator <(const Line &m) const{ return h < m.h;}
}line[N];
void push_up(ll p, ll pl, ll pr)
{
    //len1
    if(cnt[p])
        tree[p] = xx[pr] - xx[pl];
    else if(pl + 1 == pr)
        tree[p] = 0;
    else
        tree[p] = tree[ls] + tree[rs];
    
    //对于len2的更新情况进行讨论：
    //经过一次 覆盖 或 撤除 后 (cnt[p] += d)：
    //1. 当区间p至少共被一次性完全覆盖过两次时，此时 cnt[p] >= 2，说明整段p都是有效覆盖长度len2，即 tree2[p] = xx[pr] - xx[pl]
    //2. 当区间p没达到有效覆盖要求，且为叶子结点(这里是长度为1的最小区间)时，没办法再向下索取长度，只能 tree2[p] = 0
    //3. 当区间p(非叶子)被一次性完全覆盖过一次时，此时cnt[p] == 1，说明它有资格向下从左右子索取同样是曾被覆盖过一次的长度len1，这部分加起来就覆盖了两次
    //   即 tree2[p] = tree[ls] + tree[rs] 
    //4. 当区间p(非叶子)从没被一次性完全覆盖过时，此时cnt[p] == 0，注意只是没有一次性覆盖完，它还可以从左右子len2索取有效覆盖长度
    //   即 tree2[p] = tree2[ls] + tree2[rs]
    if(cnt[p] > 1)
        tree2[p] = xx[pr] - xx[pl];//对len2，至少覆盖两次时 长度有效
    else if(pl + 1 == pr)
        tree2[p] = 0;
    else if(cnt[p] == 1)//重点
        tree2[p] = tree[ls] + tree[rs];
    else
        tree2[p] = tree2[ls] + tree2[rs];
}
void update(ll L, ll R, ll p, ll pl, ll pr, ll d)
{
    if(L <= pl && R >= pr)
    {
        cnt[p] += d;
        push_up(p, pl, pr);
        return;
    }
    if(pl + 1 == pr) return;
    ll mid = pl + pr >> 1;
    if(L <= mid) update(L, R, ls, pl, mid, d);
    if(R > mid) update(L, R, rs, mid, pr, d);
    push_up(p, pl, pr);
}
int main()
{
    scanf("%d", &T);
    while(T--)
    {
        memset(cnt, 0, sizeof(cnt));
        memset(tree, 0, sizeof(tree));
        memset(tree2, 0, sizeof(tree2));
        db ans = 0;
        ll ind = 0;
        scanf("%d", &n);
        for(int i = 1; i <= n; i++)
        {
            db x1, y1, x2, y2;
            scanf("%lf%lf%lf%lf", &x1, &y1, &x2, &y2);
            line[++ind] = Line(x1, x2, y1, 1);
            xx[ind] = x1;
            line[++ind] = Line(x1, x2, y2, -1);
            xx[ind] = x2;
        }
        sort(line + 1, line + 1 + ind);
        sort(xx + 1, xx + 1 + ind);
        ll num = unique(xx + 1, xx + 1 + ind) - xx - 1;
        for(int i = 1; i <= ind; i++) 
        {
            ans += tree2[1] * (line[i].h - line[i - 1].h);
            ll L = lower_bound(xx + 1, xx + 1 + num, line[i].lx) - xx;
            ll R = lower_bound(xx + 1, xx + 1 + num, line[i].rx) - xx;
            update(L, R, 1, 1, num, line[i].d);
        }
        printf("%.2f\n", ans);
    }
    return 0;
}
```





##### 矩形周长并

```c++
1.Picture
给n个矩形，求n个矩形合并后的周长是多少。(数据都是整数)
重点：判断当前扫描线是否被已有长度所覆盖，若是则不能计算该扫描线。
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
#include <cmath>
using namespace std;
#define ls (p << 1)
#define rs (p << 1 | 1)
#define ll int
const ll N = 1e4 + 5;//这里一定要开够大
struct Line{
    ll lx, rx, h, d;
    Line(ll a = 0, ll b = 0, ll c = 0, ll dd = 0) {lx = a, rx = b, h = c, d = dd;}
    bool operator <(const Line &m) const{ return h < m.h;}
}line[N << 1];
struct nd{
    ll len;               //总有效长度
    bool l_cover, r_cover;//标记线段左、右端点是否被覆盖
    nd(ll s = 0, bool a = 0, bool b = 0) {len = s, l_cover = a, r_cover = b;}
}tree[N << 2];
ll n, ind = 0, ans = 0, last = 0;
ll cnt[N << 2], num[N << 2], xx[N];//cnt记录区间入边出边情况，而num记录区间内有多少条独立的线段以计算出有多少对竖边
void push_up(ll p, ll pl, ll pr)
{
    if(cnt[p])            //区间p有效，且整个区间p已被完全覆盖，则此时独立线段个数仅1条
    {
        tree[p] = nd(xx[pr] - xx[pl], 1, 1);
        num[p] = 1;
    }
    else if(pl + 1 == pr)
    {
        tree[p] = nd(0, 0, 0);
        num[p] = 0;       //这里记得清空为0，因为出边后叶子节点已经无法从下面索取到有效长度，拥有的线段数量自然也必须为0
    }
    else                  //向上传递覆盖性、有效长度 和 独立线段个数
    {
        tree[p] = nd(tree[ls].len + tree[rs].len, tree[ls].l_cover, tree[rs].r_cover);
        num[p] = num[ls] + num[rs];
        if(tree[ls].r_cover && tree[rs].l_cover) num[p]--;//左右子线段合并
    }
}
void update(ll L, ll R, ll p, ll pl, ll pr, ll d)
{
    if(L <= pl && R >= pr)
    {
        cnt[p] += d;
        push_up(p, pl, pr);
        return;
    }
    if(pl + 1 == pr) return;
    ll mid = pl + pr >> 1;
    if(L <= mid) update(L, R, ls, pl, mid, d);
    if(R > mid) update(L, R, rs, mid, pr, d);

    push_up(p, pl, pr);
    // 也可以分出来写    
    // if(!cnt[p])
    // {
    //     tree[p] = nd(tree[ls].len + tree[rs].len, tree[ls].l_cover, tree[rs].r_cover);
    //     num[p] = num[ls] + num[rs];
    //     if(tree[ls].r_cover && tree[rs].l_cover) num[p]--;
    // }
}
int main()
{
    scanf("%d", &n);
    for(int i = 1; i <= n; i++)
    {
        ll x1, y1, x2, y2;
        scanf("%d%d%d%d", &x1, &y1, &x2, &y2);
        line[++ind] = Line(x1, x2, y1, 1);
        xx[ind] = x1;
        line[++ind] = Line(x1, x2, y2, -1);
        xx[ind] = x2;
    }
    sort(line + 1, line + 1 + ind);
    sort(xx + 1, xx + 1 + ind);
    ll max_x = unique(xx + 1, xx + 1 + ind) - xx - 1;
    for(int i = 1; i <= ind; i++)
    {
        ll L = lower_bound(xx + 1, xx + 1 + max_x, line[i].lx) - xx;
        ll R = lower_bound(xx + 1, xx + 1 + max_x, line[i].rx) - xx;
        update(L, R, 1, 1, max_x, line[i].d);
        ans += 2 * num[1] * (line[i + 1].h - line[i].h);//总竖边长(2 * 竖边对数num * 长度)
        ans += abs(tree[1].len - last);                 //底边长(除去了覆盖部分)
        last = tree[1].len;
    }
    printf("%d\n", ans);
    return 0;
}
```



##### 矩体体积并（三维扫描线）

```c++
1.Get The Treasury （枚举 + 三维扫描线）
参考：https://blog.csdn.net/qq_41280600/article/details/104094400
题意：给若干个矩体（长方体），求至少重合三次的体积之和。
思路：维护x, y的面积并，枚举 z (|z| < 500 且为整数)，每次枚举都相当于寻找高度为1的矩体三次重叠部分的体积 -- 体积元。
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;
#define ls (p << 1)
#define rs (p << 1 | 1)
#define lc ls, pl, mid
#define rc rs, mid + 1, pr
#define ll long long
const ll N = 2e4 + 5;
ll n, T, cnt[N << 2];
ll xx[N], yy[N], zz[N];
struct Line{
    ll lx, rx, y, d;
    ll z1, z2;//所属矩体高度范围
    Line(ll a = 0, ll b = 0, ll c = 0, ll dd = 0, ll e = 0, ll f = 0){ lx = a, rx = b, y = c, d = dd, z1 = e, z2 = f;}
    bool operator <(const Line &m) const{ return y < m.y;}
}line[N];
struct nd{
    ll len1, len2, len3;
    nd(ll l1 = 0, ll l2 = 0, ll l3 = 0) {len1 = l1, len2 = l2, len3 = l3;}
}tree[N << 2];
void build(ll p, ll pl, ll pr)
{
    tree[p] = nd(0, 0, 0);
    cnt[p] = 0;
    if(pl == pr) return;
    ll mid = pl + pr >> 1;
    build(lc);
    build(rc);
}
void push_up(ll p, ll pl, ll pr)                                      //记得 xx[pr + 1] - xx[pl]
{
    if(cnt[p]) tree[p].len1 = xx[pr + 1] - xx[pl];
    else if(pl == pr) tree[p].len1 = 0;
    else tree[p].len1 = tree[ls].len1 + tree[rs].len1;

    if(cnt[p] >= 2) tree[p].len2 = xx[pr + 1] - xx[pl];
    else if(pl == pr) tree[p].len2 = 0;
    else if(cnt[p] == 1) tree[p].len2 = tree[ls].len1 + tree[rs].len1;//只差一次覆盖，从len1拿
    else tree[p].len2 = tree[ls].len2 + tree[rs].len2;

    if(cnt[p] >= 3) tree[p].len3 = xx[pr + 1] - xx[pl];
    else if(pl == pr) tree[p].len3 = 0;
    else if(cnt[p] == 2) tree[p].len3 = tree[ls].len1 + tree[rs].len1;//只差一次覆盖，从len1拿
    else if(cnt[p] == 1) tree[p].len3 = tree[ls].len2 + tree[rs].len2;//还差两次覆盖，从len2拿
    else tree[p].len3 = tree[ls].len3 + tree[rs].len3;
    
}
void update(ll L, ll R, ll p, ll pl, ll pr, ll d)
{
    if(L <= pl && R >= pr)
    {
        cnt[p] += d;
        push_up(p, pl, pr);
        return;
    }
    if(pl == pr) return;
    ll mid = pl + pr >> 1;
    if(L <= mid) update(L, R, lc, d);
    if(R > mid) update(L, R, rc, d);
    push_up(p, pl, pr);
}
int main()
{
    scanf("%lld", &T);
    for(int _ = 1; _ <= T; _++)
    {
        ll ind = 0, ans = 0;
        scanf("%lld", &n);

        for(int i = 1; i <= n; i++)
        {
            ll x1, y1, z1, x2, y2, z2;
            scanf("%lld%lld%lld%lld%lld%lld", &x1, &y1, &z1, &x2, &y2, &z2);
            line[++ind] = Line(x1, x2, y1, 1, z1, z2);
            xx[ind] = x1, zz[ind] = z1;
            line[++ind] = Line(x1, x2, y2, -1, z1, z2);
            xx[ind] = x2, zz[ind] = z2;
        }

        sort(xx + 1, xx + 1 + ind);
        sort(line + 1, line + 1 + ind);
        ll num_x = unique(xx + 1, xx + 1 + ind) - xx - 1;

        for(int z = -500; z <= 500; z++)             //遍历所有体积元
        {
            build(1, 1, num_x);
            ll area = 0, last = 0;                   //扫描面符合条件的面积
            for(int i = 1; i <= ind; i++)            //遍历所有属于体积元所在的矩体连结体的"扫描面"
            {
                if(line[i].z1 <= z && z < line[i].z2)//一个矩体的体积元个数为 z2 - z1 个，即区间 [z1, z2)，合起来恰好是该矩体的体积
                {
                    //这里不能直接 line[i].y - line[i-1].y，因为最开始一次扫描line[i-1].y不一定就是line[0].y 即不一定为0，所以很可能减多了
                    //这也是没有对 Z坐标 离散化处理的弊端
                    area += tree[1].len3 * (line[i].y - last);
                    last = line[i].y;
                    ll L = lower_bound(xx + 1, xx + 1 + num_x, line[i].lx) - xx;
                    ll R = lower_bound(xx + 1, xx + 1 + num_x, line[i].rx) - xx;
                    update(L, R - 1, 1, 1, num_x, line[i].d);
                }
            }
            ans += area;                             //相当于加一个高为1的矩体体积 ans += 1 * area
        }
        printf("Case %d: %lld\n", _, ans);
    }
    return 0;
}
```







#### 其他问题

##### dfs序

* dfs序是指：每个节点在dfs深度优先遍历中的进出栈的时间序列。



```c++
1.Assign the task
题意：给你一棵树，共n个结点，每个结点具有一个颜色，可以对结点所处的子树（包括其自身）的染色 以及 查询某结点的颜色。
先建图存树，用 dfs序 将 树 区间化，可以求出每个节点的管辖区间（即 所得该节点区间 表示 以该节点为根的子树），以此维护任意一个子树或单个结点的变化。
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <vector>
#include <cstring>
using namespace std;
#define ls (p << 1)
#define rs (p << 1 | 1)
#define lc ls, pl, mid
#define rc rs, mid + 1, pr
#define ll int
const int N = 5e4 + 5;
ll tree[N << 2], tag[N << 2];
ll in[N], out[N];//记录结点在dfs序上进出栈的时间
ll n, q, time = 0;//时间
ll indegree[N];//记录入度，方便找树根
vector<ll> G[N];
void init()
{
    memset(indegree, 0, sizeof(indegree));
    memset(tree, -1, sizeof(tree));
    memset(tag, -1, sizeof(tag));
    for(int i = 1; i <= n; i++) G[i].clear();
    time = 0;
}
void dfs(int u)
{
    in[u] = ++time;
    for(int i = 0; i < G[u].size(); i++) dfs(G[u][i]);
    out[u] = time;
}
void push_down(ll p)
{
    if(tag[p] != -1)
    {
        tree[ls] = tree[rs] = tag[p];
        tag[ls] = tag[rs] = tag[p];
        tag[p] = -1;
    }
}
void update(ll L, ll R, ll p, ll pl, ll pr, ll d)
{
    if(L <= pl && R >= pr)
    {
        tree[p] = tag[p] = d;
        return;
    }
    push_down(p);
    ll mid = pl + pr >> 1;
    if(L <= mid) update(L, R, lc, d);
    if(R > mid) update(L, R, rc, d);
}
ll query(ll x, ll p, ll pl, ll pr)
{
    if(pl == pr) return tree[p];
    push_down(p);
    ll mid = pl + pr >> 1;
    if(x <= mid) return query(x, lc);
    else return query(x, rc);
}
int main()
{
    int T;
    scanf("%d", &T);
    for(int _ = 1; _ <= T; _++)
    {
        printf("Case #%d:\n", _);
        scanf("%d", &n);
        init();
        for(int i = 1; i < n; i++)//n个结点建一颗单根树，需要 n-1 条边
        {
            ll u, v;
            scanf("%d%d", &v, &u);
            G[u].push_back(v);
            ++indegree[v];
        }
        //存储dfs时间序列
        for(int i = 1; i <= n; i++)
        {
            if(!indegree[i]) //从树根出发一次即可
            {
                dfs(i);
                break;
            }
        }
        scanf("%d", &q);
        while(q--)
        {
            char op[5];
            ll x, d;
            scanf("%s", &op);
            if(op[0] == 'T')
            {
                scanf("%d%d", &x, &d);
                update(in[x], out[x], 1, 1, n, d);
            }
            else
            {
                scanf("%d", &x);
                printf("%d\n", query(in[x], 1, 1, n));
            }
        }
    }
    return 0;
}
```



##### 混合多种区间操作

* 区间操作有：单点\区间修改（加值、乘值、置值、取反等）、单点\区间查询（区间和、区间平方和、区间立方和等）
* 重点：标记间的优先级（覆盖性）



```c++
1.Transformation
一个长为n的序列，对区间[l,r]有4种操作：每个数加c，每个数乘c，每个数置为c，查询每个数p次方后的区间和
思路1：对查询操作的p次方和，用s[3]分别存起1次到3次方的值，传递时结合完全平方式和完全立方式
对于(x + d)^3 = x^3 + 3 * x^2 * d + 3 * x * d^2 + d^3，拓展到长度为len的区间得到：Σ(x + d)^3 = Σx^3 + 3 * d * Σ(x^2) + 3 * d^2 * Σx + Σd^3
即tree[p].s[2] = tree[p].s[2] + 3 * d * tree[p].s[1] + 3 * d * d * tree[p].s[0] + len * d * d * d 
对 (x + d)^2 = x^2 + 2*d*x + d^2 同理。
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <vector>
#include <cstring>
#include <cmath>
using namespace std;
#define ls (p << 1)
#define rs (p << 1 | 1)
#define lc ls, pl, mid
#define rc rs, mid + 1, pr
#define ll int
#define mod(x) ((x) % 10007)
const int N = 1e5 + 5;
ll n, m;
struct nd{
    ll s[3];
    ll sum, mul, setx;
}tree[N << 2];
void addtag_sum(ll p, ll pl, ll pr, ll d)//注意三种求和的更新先后关系
{
    ll len = pr - pl + 1;
    tree[p].s[2] = mod(tree[p].s[2] + mod(3 * d * tree[p].s[1]) + mod(mod(3 * d * d) * tree[p].s[0]) + mod(mod(mod(len * d) * d) * d));
    tree[p].s[1] = mod(tree[p].s[1] + mod(2 * d * tree[p].s[0]) + mod(mod(len * d) * d));
    tree[p].s[0] = mod(tree[p].s[0] + mod(len * d));
    tree[p].sum  = mod(tree[p].sum + d);
}
void addtag_mul(ll p, ll pl, ll pr, ll d)
{
    tree[p].s[2] = mod(mod(mod(tree[p].s[2] * d) * d) * d);
    tree[p].s[1] = mod(mod(tree[p].s[1] * d) * d);
    tree[p].s[0] = mod(tree[p].s[0] * d);
    tree[p].sum  = mod(tree[p].sum * d);
    tree[p].mul  = mod(tree[p].mul * d);
}
void addtag_set(ll p, ll pl, ll pr, ll d)
{
    ll len = pr - pl + 1;
    tree[p].s[2] = mod(mod(mod(len * d) * d) * d);
    tree[p].s[1] = mod(mod(len * d) * d);
    tree[p].s[0] = mod(len * d);
    tree[p].setx = d;
    tree[p].mul = 1;//向下传递覆盖信息
    tree[p].sum = 0;
}
void push_up(ll p)
{
    for(int i = 0; i < 3; i++) tree[p].s[i] = mod(tree[ls].s[i] + tree[rs].s[i]);
}
void push_down(ll p, ll pl, ll pr)//注意标记更新的先后关系和覆盖性
{
    ll mid = pl + pr >> 1;
    if(tree[p].setx != -1)//覆盖其他标记
    {
        addtag_set(lc, tree[p].setx);
        addtag_set(rc, tree[p].setx);
        tree[p].setx = -1;
    }

    if(tree[p].mul != 1)
    {
        addtag_mul(lc, tree[p].mul);
        addtag_mul(rc, tree[p].mul);
        tree[p].mul = 1;
    }
    if(tree[p].sum)
    {
        addtag_sum(lc, tree[p].sum);
        addtag_sum(rc, tree[p].sum);
        tree[p].sum = 0;
    }
    // tree[p].sum = 0, tree[p].mul = 1, tree[p].setx = -1;
}
void build(ll p, ll pl, ll pr)
{
    tree[p].s[0] = tree[p].s[1] = tree[p].s[2] = tree[p].sum = 0;
    tree[p].mul = 1, tree[p].setx = -1;
    if(pl == pr) return;
    ll mid = pl + pr >> 1;
    build(lc);
    build(rc);
}
void update(ll L, ll R, ll p, ll pl, ll pr, ll op, ll d)
{
    if(L <= pl && R >= pr)
    {
        if(op == 1) addtag_sum(p, pl, pr, d);
        else if(op == 2) addtag_mul(p, pl, pr, d);
        else addtag_set(p, pl, pr, d);
        return;
    }
    push_down(p, pl, pr);
    ll mid = pl + pr >> 1;
    if(L <= mid) update(L, R, lc, op, d);
    if(R > mid) update(L, R, rc, op, d);
    push_up(p);
}
ll query(ll L, ll R, ll p, ll pl, ll pr, ll d)
{
    if(L <= pl && R >= pr) return mod(tree[p].s[d]);
    push_down(p, pl, pr);
    ll mid = pl + pr >> 1, ans = 0;
    if(L <= mid) ans = mod(ans + query(L, R, lc, d));
    if(R > mid) ans = mod(ans + query(L, R, rc, d));
    return mod(ans);
}
int main()
{
    while(~scanf("%d%d", &n, &m))//while(~scanf("%d%d", &n, &m), n) 会WA
    {
        if(n + m == 0) break;
        build(1, 1, n);
        while(m--)
        {
            ll op, x, y, k;
            scanf("%d%d%d%d", &op, &x, &y, &k);
            if(op == 4) printf("%d\n", query(x, y, 1, 1, n, k - 1));
            else update(x, y, 1, 1, n, op, k);
        }
    }
    return 0;
}



2.序列操作
两种区间修改：
    区间置为0\1 、 区间取反
两种查询操作：
    区间和、最长连续1串长度
/*
如序列 01101011
            01101011
      0110           1011
   01      10     10      11
 0   1   1   0   1   0   1   1
push_up():
    1. 1的个数sum，即两子区间的sum之和
    2. 连续1的最大数量cnt，
        若 左儿子的cntr && 右儿子的cntl，则 cnt = 左儿子区间从右往左的连续1数量cntr + 右儿子区间从左往右的连续1数量cntl
        若有一个为0则无法连接，取max(左儿子cnt，右儿子cnt)
    3. 由于翻转操作的存在，连续0串的最大数量也需同上存储，最终视 是否进行了翻转 来决定是取 连续0 还是 连续1 的个数
操作优先级：取反（单点修改置值1或0），则当 (tag0 || tag1) == 1 时取反操作应用到两个标记上，对两标记取反，否则对 nega_tag取反
该题实际操作过程中极容易出错。
*/
#include <cstdio>
#include <iostream>
#include <algorithm>
using namespace std;
#define ll int
#define il inline
#define ls (p << 1)
#define rs (p << 1 | 1)
const int N = 2e5 + 10;
struct node{
    ll sum, cnt[2], cntl[2], cntr[2];//要查询的值，1的个数(亦可得出0的个数)、连续0\1的最大数量，从左往右最长0\1个数cntl，从右往左最长0\1个数cntr
    ll set_tag, nega_tag;//lazy标记，set_tag初始为-1，若为0或1则说明置为0或1，nega_tag 为1说明进行取反操作
    ll len;//特别地，存一下该区间长度
}tree[N << 2];
ll n, m;
il void push_up(ll p)
{
    tree[p].sum = tree[ls].sum + tree[rs].sum;
    for(int i = 0; i < 2; i++)
    {
        tree[p].cntl[i] = tree[ls].cntl[i];//先传递左子的cntl，作为当前区间的cntl
        if(tree[ls].cntl[i] == tree[ls].len) tree[p].cntl[i] += tree[rs].cntl[i]; //如果左子是全1串，那么当前区间的cntl可以继续接上右子的cntl
        tree[p].cntr[i] = tree[rs].cntr[i];//同上
        if(tree[rs].cntr[i] == tree[rs].len) tree[p].cntr[i] += tree[ls].cntr[i];
        //上述更新的是cntl 和 cntr，现在更新cnt
        tree[p].cnt[i] = max(tree[ls].cntr[i] + tree[rs].cntl[i], max(tree[ls].cnt[i], tree[rs].cnt[i])); //合并后中间连续串 与 左、右连续子串 求三者的最大
    }
}
il void push_set(ll p, ll d)
{
    tree[p].set_tag = d, tree[p].nega_tag = 0, tree[p].sum = d * tree[p].len;
    tree[p].cnt[d] = tree[p].cntl[d] = tree[p].cntr[d] = tree[p].len;
    tree[p].cnt[!d] = tree[p].cntl[!d] = tree[p].cntr[!d] = 0;
}
il void push_rev(ll p)
{
    tree[p].sum = tree[p].len - tree[p].sum;
    swap(tree[p].cnt[0], tree[p].cnt[1]);
    swap(tree[p].cntl[0], tree[p].cntl[1]);
    swap(tree[p].cntr[0], tree[p].cntr[1]);
    if(tree[p].set_tag != -1) tree[p].set_tag ^= 1;//影响置值
    else tree[p].nega_tag ^= 1;
}
il void push_down(ll p, ll pl, ll pr)
{
    ll mid = (pl + pr) >> 1;
    if(tree[p].set_tag != -1)
    {
        push_set(ls, tree[p].set_tag);
        push_set(rs, tree[p].set_tag);
        tree[p].set_tag = -1;
    }
    if(tree[p].nega_tag)
    {
        push_rev(ls);
        push_rev(rs);
        tree[p].nega_tag = 0;
    }
}
void build(ll p, ll pl, ll pr)
{
    tree[p].set_tag = -1, tree[p].len = pr - pl + 1;
    if(pl == pr)
    {
        ll d; scanf("%d", &d);
        tree[p].sum = d, tree[p].cnt[d] = tree[p].cntl[d] = tree[p].cntr[d] = 1;
        return;
    }
    ll mid = (pl + pr) >> 1;
    build(ls, pl, mid);
    build(rs, mid + 1, pr);
    push_up(p);
}
void update(ll L, ll R, ll p, ll pl, ll pr, ll d)
{
    if(L <= pl && R >= pr){ d == 2 ? push_rev(p) : push_set(p, d); return;}
    push_down(p, pl, pr);
    ll mid = (pl + pr) >> 1;
    if(L <= mid) update(L, R, ls, pl, mid, d);
    if(R > mid) update(L, R, rs, mid + 1, pr, d);
    push_up(p);
}
ll query(ll L, ll R, ll p, ll pl, ll pr)
{
    if(L <= pl && R >= pr) return tree[p].sum;
    push_down(p, pl, pr);
    ll mid = (pl + pr) >> 1, res = 0;
    if(L <= mid) res += query(L, R, ls, pl, mid);
    if(R > mid) res += query(L, R, rs, mid + 1, pr);
    return res;
}
ll query2(ll L, ll R, ll p, ll pl, ll pr)
{
    if(L <= pl && R >= pr) return tree[p].cnt[1];
    push_down(p, pl, pr);
    ll mid = (pl + pr) >> 1;
    if(R <= mid) return query2(L, R, ls, pl, mid);
    else if(L > mid) return query2(L, R, rs, mid + 1, pr);
    else return max(max(query2(L, mid, ls, pl, mid), query2(mid + 1, R, rs, mid + 1, pr)), min(tree[ls].cntr[1], mid + 1 - L) + min(tree[rs].cntl[1], R - mid));
}
int main()
{
    ll n, m;
    scanf("%d%d", &n, &m);
    build(1, 1, n); 
    while(m--)
    {
        ll q, L, R, d;
        scanf("%d%d%d", &q, &L, &R);
        ++L, ++R;
        if(q == 3) printf("%d\n", query(L, R, 1, 1, n));
        else if(q == 4) printf("%d\n", query2(L, R, 1, 1, n));
        else update(L, R, 1, 1, n, q);
    }
    return 0;
}
//query2如下写法也行
// node query2(ll L, ll R, ll p, ll pl, ll pr)
// {
//     if(L <= pl && R >= pr) 
//     {
//         return tree[p];
//     }
//     push_down(p, pl, pr);
//     ll mid = (pl + pr) >> 1;
//     if(L <= mid && R > mid)
//     {
//         node lans, rans, ans;
//         lans = query2(L, R, ls, pl, mid);
//         rans = query2(L, R, rs, mid + 1, pr);
//         ans.cntl[1] = lans.cntl[1];
//         if(lans.cntl[1] == lans.len) ans.cntl[1] += rans.cntl[1];
//         ans.cntr[1] = rans.cntr[1];
//         if(rans.cntr[1] == rans.len) ans.cntr[1] += lans.cntr[1];
//         ans.cnt[1] = max(lans.cntr[1] + rans.cntl[1], max(lans.cnt[1], rans.cnt[1]));
//         return ans;
//     }
//     if(L <= mid) return query2(L, R, ls, pl, mid);
//     if(R > mid) return query2(L, R, rs, mid + 1, pr);
// }

```



##### 基于二叉树结构的二分搜索



```c++
1.Vases and Flowers
操作1：从A开始，只对空瓶插花，最多插F朵花或花瓶遍历完时停止；
操作2：相当于先 求区间和 再 清空区间。
操作2实现简单，而操作1则需要利用 线段树的二分结构 去 二分搜索 第一个 和 最后一个 空瓶的位置。
#include <cstdio>
#include <iostream>
#include <algorithm>
using namespace std;
#define ls (p << 1)
#define rs (p << 1 | 1)
#define lc ls, pl, mid
#define rc rs, mid + 1, pr
#define ll int
const int N = 5e4 + 5;
ll n, m;
ll tree[N << 2], tag[N << 2];
void push_up(ll p) {tree[p] = tree[ls] + tree[rs];}
void push_down(ll p, ll pl, ll pr)
{
    if(tag[p] != -1)
    {
        ll mid = pl + pr >> 1;
        tree[ls] = tag[p] * (mid - pl + 1);
        tree[rs] = tag[p] * (pr - mid);
        tag[ls] = tag[rs] = tag[p];
        tag[p] = -1;
    }
}
void build(ll p, ll pl, ll pr)
{
    tree[p] = 0, tag[p] = -1;
    if(pl == pr) return;
    ll mid = pl + pr >> 1;
    build(lc);
    build(rc);
}
void update(ll L, ll R, ll p, ll pl, ll pr, ll d)
{
    if(L <= pl && R >= pr)
    {
        tree[p] = d * (pr - pl + 1);
        tag[p] = d;
        return;
    }
    push_down(p, pl, pr);
    ll mid = pl + pr >> 1;
    if(L <= mid) update(L, R, lc, d);
    if(R > mid) update(L, R, rc, d);
    push_up(p);
}
ll query_sum(ll L, ll R, ll p, ll pl, ll pr)
{
    if(L <= pl && R >= pr) return tree[p];
    push_down(p, pl, pr);
    ll mid = pl + pr >> 1, res = 0;
    if(L <= mid) res += query_sum(L, R, lc);
    if(R > mid) res += query_sum(L, R, rc);
    return res;
}
ll query_ind(ll st, ll cnt)//cnt为要找第几个0
{
    ll l = st, r = n, res = -1;
    while(l <= r)
    {
        ll mid = l + r >> 1;
        ll sum = mid - st + 1 - query_sum(st, mid, 1, 1, n);
        if(sum >= cnt) res = mid, r = mid - 1;//数量充分，收束右端
        else l = mid + 1;
    }
    return res;
}
int main()
{
    int T;
    scanf("%d", &T);
    while(T--)
    {
        scanf("%d%d", &n, &m);
        build(1, 1, n);
        while(m--)
        {
            ll op, a, b, posl, posr;
            scanf("%d%d%d", &op, &a, &b);
            ++a;
            if(op == 1)
            {
                posl = query_ind(a, 1);//第1个空花瓶位置
                if(posl == -1)//如果一个都没有就输出
                    printf("Can not put any one.\n");
                else
                {
                    ll sum = n - posl + 1 - query_sum(posl, n, 1, 1, n);//用于判断给的花是不是比空花瓶多
                    posr = query_ind(a, min(b, sum));//第b个空花瓶位置
                    printf("%d %d\n", posl - 1, posr - 1);
                    update(posl, posr, 1, 1, n, 1);
                }
            }
            else
            {
                ++b;
                printf("%d\n", query_sum(a, b, 1, 1, n));
                update(a, b, 1, 1, n, 0);
            }
        }
        printf("\n");
    }
    return 0;
}
```











